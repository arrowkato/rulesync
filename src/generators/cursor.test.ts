import { beforeEach, describe, expect, it, vi } from "vitest";
import type { Config, ParsedRule } from "../types/index.js";
import { loadIgnorePatterns } from "../utils/ignore.js";
import { generateCursorConfig } from "./cursor.js";

vi.mock("../utils/ignore.js", () => ({
  loadIgnorePatterns: vi.fn(),
}));

describe("generateCursorConfig", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  const mockConfig: Config = {
    projectName: "test-project",
    rulesDir: ".rulesync",
    outputPaths: {
      copilot: ".github/instructions",
      cursor: ".cursor/rules",
      cline: ".clinerules",
      claudecode: "",
      roo: ".roo/rules",
      geminicli: "",
    },
  };

  const mockRule: ParsedRule = {
    frontmatter: {
      root: true,
      targets: ["cursor"],
      description: "Test rule",
      globs: ["**/*.ts"],
    },
    content: "Test rule content",
    filename: "test-rule",
    filepath: ".rulesync/test-rule.md",
  };

  it("should generate cursor config files", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({ patterns: [] });

    const outputs = await generateCursorConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(1);
    expect(outputs[0]).toEqual({
      tool: "cursor",
      filepath: ".cursor/rules/test-rule.mdc",
      content: expect.stringContaining("description: Test rule"),
    });
  });

  it("should generate .cursorignore when .rulesyncignore exists", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({
      patterns: ["*.test.md", "temp/**/*"],
    });

    const outputs = await generateCursorConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(2);

    // Check rule file
    expect(outputs[0].filepath).toBe(".cursor/rules/test-rule.mdc");

    // Check .cursorignore file
    expect(outputs[1]).toEqual({
      tool: "cursor",
      filepath: ".cursorignore",
      content: expect.stringContaining("# Generated by rulesync from .rulesyncignore"),
    });
    expect(outputs[1].content).toContain("*.test.md");
    expect(outputs[1].content).toContain("temp/**/*");
  });

  it("should not generate .cursorignore when no ignore patterns exist", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({ patterns: [] });

    const outputs = await generateCursorConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(1);
    expect(outputs.every((o) => o.filepath !== ".cursorignore")).toBe(true);
  });

  it("should respect baseDir parameter", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({
      patterns: ["*.test.md"],
    });

    const outputs = await generateCursorConfig([mockRule], mockConfig, "/custom/base");

    expect(outputs).toHaveLength(2);
    expect(outputs[0].filepath).toBe("/custom/base/.cursor/rules/test-rule.mdc");
    expect(outputs[1].filepath).toBe("/custom/base/.cursorignore");
  });
});
